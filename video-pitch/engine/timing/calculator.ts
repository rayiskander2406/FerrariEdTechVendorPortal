/**
 * Timing Calculator
 *
 * Automatically generates SCENES object from audio files.
 * Eliminates manual timing errors and drift.
 *
 * Usage:
 *   npx ts-node calculator.ts /path/to/voiceover/
 *
 * Outputs:
 *   - SCENES const for Main.tsx
 *   - Total duration for Root.tsx
 */

import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

interface SceneTiming {
  name: string;
  file: string;
  duration: number;
  start: number;
  end: number;
}

interface TimingResult {
  scenes: SceneTiming[];
  totalDuration: number;
  scenesCode: string;
  rootDuration: string;
}

/**
 * Get audio duration using ffprobe
 */
function getAudioDuration(filePath: string): number {
  try {
    const result = execSync(
      `ffprobe -v quiet -show_entries format=duration -of csv=p=0 "${filePath}"`,
      { encoding: 'utf-8' }
    );
    return parseFloat(result.trim());
  } catch (error) {
    console.error(`Error getting duration for ${filePath}:`, error);
    return 0;
  }
}

/**
 * Extract scene name from filename
 * e.g., "scene1_hook.mp3" → "hook"
 * e.g., "scene1b_stats.mp3" → "hookStats"
 */
function extractSceneName(filename: string): string {
  const nameMap = new Map<string, string>([
    ['scene1_hook', 'hook'],
    ['scene1b_stats', 'hookStats'],
    ['scene2_problem', 'problem'],
    ['scene3_solution', 'solution'],
    ['scene4_integration', 'integration'],
    ['scene5_benefits', 'benefits'],
    ['scene6_leverage', 'leverage'],
    ['scene7_close', 'close'],
  ]);

  const base = path.basename(filename).replace(/\.(mp3|wav)$/, '');

  // Remove version suffixes like _v124, _v124b
  const cleanBase = base.replace(/_v\d+[a-z]?$/, '');

  return nameMap.get(cleanBase) || cleanBase;
}

/**
 * Calculate timing from audio files in a directory
 */
export function calculateTiming(audioDir: string, concatFile?: string): TimingResult {
  let files: string[];

  if (concatFile && fs.existsSync(path.join(audioDir, concatFile))) {
    // Use concat file order
    const content = fs.readFileSync(path.join(audioDir, concatFile), 'utf-8');
    files = content
      .split('\n')
      .filter((line) => line.startsWith("file '"))
      .map((line) => {
        const match = line.match(/file '(.+)'/);
        return match && match[1] ? path.join(audioDir, match[1]) : '';
      })
      .filter((f) => f && fs.existsSync(f));
  } else {
    // Auto-detect scene files
    files = fs
      .readdirSync(audioDir)
      .filter((f) => f.match(/^scene\d+[a-z]?_\w+\.(mp3|wav)$/))
      .filter((f) => !f.includes('_1.5x') && !f.includes('_1.2x') && !f.includes('_fast'))
      .sort()
      .map((f) => path.join(audioDir, f));
  }

  if (files.length === 0) {
    throw new Error(`No audio files found in ${audioDir}`);
  }

  const scenes: SceneTiming[] = [];
  let currentTime = 0;

  for (const file of files) {
    const duration = getAudioDuration(file);
    const name = extractSceneName(file);

    scenes.push({
      name,
      file: path.basename(file),
      duration,
      start: currentTime,
      end: currentTime + duration,
    });

    currentTime += duration;
  }

  const totalDuration = currentTime;

  // Generate Main.tsx SCENES code
  const scenesCode = generateScenesCode(scenes, totalDuration);

  // Generate Root.tsx duration line
  const rootDuration = `durationInFrames={Math.round(${totalDuration.toFixed(2)} * 30)} // ${totalDuration.toFixed(2)} seconds at 30fps`;

  return { scenes, totalDuration, scenesCode, rootDuration };
}

/**
 * Generate SCENES const code for Main.tsx
 */
function generateScenesCode(scenes: SceneTiming[], total: number): string {
  const lines = scenes.map((s) => {
    const startRounded = s.start.toFixed(2);
    const endRounded = s.end.toFixed(2);
    const comment = `// ${startRounded}-${endRounded}s ${s.name}`;
    return `  ${s.name}: {start: Math.round(${startRounded} * 30), duration: Math.round(${s.duration.toFixed(2)} * 30)}, ${comment}`;
  });

  return `// Auto-generated by engine/timing/calculator.ts
// Total: ${total.toFixed(2)} seconds
const SCENES = {
${lines.join('\n')}
};`;
}

/**
 * Print timing report
 */
export function printTimingReport(result: TimingResult): void {
  console.log('\n=== TIMING REPORT ===\n');

  console.log('Scene Breakdown:');
  console.log('-'.repeat(60));

  for (const scene of result.scenes) {
    console.log(
      `  ${scene.name.padEnd(15)} ${scene.duration.toFixed(2)}s  (${scene.start.toFixed(2)}-${scene.end.toFixed(2)})`
    );
  }

  console.log('-'.repeat(60));
  console.log(`  TOTAL:         ${result.totalDuration.toFixed(2)}s`);

  console.log('\n=== MAIN.TSX CODE ===\n');
  console.log(result.scenesCode);

  console.log('\n=== ROOT.TSX DURATION ===\n');
  console.log(result.rootDuration);
}

// CLI usage
if (require.main === module) {
  const audioDir = process.argv[2];
  const concatFile = process.argv[3];

  if (!audioDir) {
    console.log('Usage: npx ts-node calculator.ts <audio-dir> [concat-file]');
    console.log('Example: npx ts-node calculator.ts ../districts/lausd/v1.2/voiceover concat_v125.txt');
    process.exit(1);
  }

  try {
    const result = calculateTiming(audioDir, concatFile);
    printTimingReport(result);
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}
